#ifndef GRAPHICAL_RENDERER_H
#define GRAPHICAL_RENDERER_H

#include <map>
#include <vector>
#include <stdexcept>
#include <iostream>

#ifdef _MAKAI_DEBUG_
#define $debug(TEXT) std::cout << TEXT << std::endl
#else
#define $debug(TEXT)
#endif // _MAKAI_DEBUG_

// #include <OGRE/Ogre.h>
#include <irrlicht.h>

#include <collection/vectorn.hpp>
#include <collection/entity/entity.hpp>
#include <collection/event.hpp>

#define DERIVED_CLASS(NAME, BASE)\
	inline	virtual string getClass() {return #NAME;}\
	inline	virtual string getBaseClass() {return #BASE;}\
	inline	static string getCoreClass() {return #NAME;}

namespace VecMath {
	namespace {
		using
		Vector::Vector2,
		Vector::Vector3;

		using namespace irr;
	}

	/// Base transformation data structure.

	template <class T>
	struct Transform {
		Transform();
		Transform(T position, T rotation, T scale) {
			this->position	= position;
			this->rotation	= rotation;
			this->scale		= scale;
		}
		T position;
		T rotation;
		T scale;
	};

	typedef Transform<Vector2> Transform2D;
	typedef Transform<Vector3> Transform3D;

	/// Converts a Vector3 to an irrlicht 3D vector.
	inline core::vector3df toIrrV3(Vector3 vec) {
		return core::vector3df(vec.x, vec.y, vec.z);
	}
	/// Converts an irrlicht 3D vector to a Vector3.
	inline Vector3 toVector3(core::vector3df vec) {
		return Vector3(vec.X, vec.Y, vec.Z);
	}

	/// Converts a Vector2 to an irrlicht 2D vector.
	inline core::vector2df toIrrV2(Vector2 vec) {
		return core::vector2df(vec.x, vec.y);
	}
	/// Converts an irrlicht 2D vector to a Vector2.
	inline Vector2 toVector2(core::vector2df vec) {
		return Vector2(vec.X, vec.Y);
	}
}

namespace RenderData {
	namespace {
		using
		Vector::Vector2,
		Vector::Vector3,
		Vector::Vector4,
		std::vector;

		using namespace irr;
	}

	template<class T>
	struct Rectangle {
		Rectangle() {}
		Rectangle(T position, T size) {
			this->position	= position;
			this->size		= size;
		}
		T position;
		T size;
	};

	typedef Rectangle<Vector2> Rectangle2D;
	typedef Rectangle<Vector3> Rectangle3D;

	typedef vector<Rectangle2D> FrameList2D;

	struct Texture2D {
		Texture2D() {}
		Texture2D(video::ITexture* image) {
			this->image = image;
			core::dimension2d<u32> size = image->getOriginalSize();
			frames.push_back(
				Rectangle2D(
					Vector2(0.0),
					Vector2(size.Width, size.Height)
				)
			);
		}
		Texture2D(video::ITexture* image, FrameList2D frames) {
			this->image = image;
			this->frames = frames;
		}
		video::ITexture* image;
		vector<Rectangle2D> frames;
	};

	core::rect<s32> toIrrRect(Rectangle2D rect) {
		return core::rect<s32>(
			rect.position.x,
			rect.position.y,
			rect.size.x,
			rect.size.y
		);
	}

	video::SColor toIrrColor(Vector4 color) {
		color *= 255;
		return video::SColor(color.w,color.x,color.y,color.z);
	}

	struct Renderable2D {
		Renderable2D() {}
		Renderable2D(irr::video::IVideoDriver* target) {
			this-> target = target;
		}
		Renderable2D(irr::video::IVideoDriver* target, Texture2D texture) {
			this-> target = target;
			this-> texture = texture;
			visible = true;
		}
		irr::video::IVideoDriver* target;
		Texture2D texture;
		Vector2 position	= Vector2(0.0);
		Vector4 color		= Vector4(1.0);
		size_t frame		= 0;
		/// Whether the sprite should be drawn to the screen.
		bool visible = false;
		void onDraw() {
			// If there are frames to be drawn, and visible...
			if (visible && texture.image) {
				if(texture.frames.size()) {
					// Draw image on target
					target->draw2DImage(
						texture.image,									// The image to be drawn
						core::position2d<s32>(position.x,position.y),	// The position to be drawn at
						toIrrRect(texture.frames[frame]),				// The frame to be drawn
						0,												// The clip rectangle
						toIrrColor((color)),							// The modulation to be drawn at
						true											// Whether to use alpha channel
					);
					// Increment frame counter
					if(++frame > texture.frames.end()) frame = 0;
				}
			}
		}
	};

	/*
	class RenderObject3D {
	public:
		RenderObject3D() {}

		RenderObject3D(EntityClass::Entity3D* parent, irr::scene::ISceneManager* scene) {
			//$debug("Creating Renderable Object...");
			this->parent = parent;
			this->scene = scene;
			//$debug("Object created!");
			//updateTransform();
		}

		void updateTransform() {
			render.node->setPosition(VecMath::toIrrV3(parent->globalPosition()));
			render.node->setRotation(VecMath::toIrrV3(parent->globalRotation()));
			render.node->setScale(VecMath::toIrrV3(parent->globalScale()));
		}

		irr::scene::IMeshSceneNode* getSceneNode() {
			return render.node;
		}

		irr::scene::IMesh* getMesh() {
			return render.mesh;
		}

		void setMesh(irr::scene::IMesh* mesh) {
			if (render.node) render.node->drop();
			//$debug("Adding Mesh...");
			render.node = scene->addMeshSceneNode(mesh);
			render.mesh = mesh;
			//$debug("Mesh Added!");
		}

		irr::scene::ISceneManager* scene = nullptr;
	private:
		struct {
			irr::scene::IMeshSceneNode* node = nullptr;
			irr::scene::IMesh* mesh = nullptr;
		} render;
		EntityClass::Entity3D* parent = nullptr;
	};

	vector<RenderObject3D*> renderList3D;
	//vector<RenderObject2D> renderList2D;*/

	//irr::scene::ISceneManager* $_DEF_SCENE;
}

namespace EntityClass {
	namespace {
		using
		Vector::Vector2,
		Vector::Vector3;

		using namespace RenderData;
	}

	/**
	*******************************
	*                             *
	*  3D Graphical Object Class  *
	*                             *
	*******************************
	*/
	/*class RenderableEntity3D: public Entity3D {
	public:
		DERIVED_CLASS(RenderableEntity3D, Entity3D)

		RenderableEntity3D(string name = "Renderable")
		: Entity3D(name) {
			object = new RenderObject3D(this, $_DEF_SCENE);
		}

		RenderableEntity3D(Entity3D* parent, string name = "Renderable", bool uniqueEntity = true)
		: Entity3D(parent, name, uniqueEntity) {
			object = new RenderObject3D(this, $_DEF_SCENE);
		}

		RenderableEntity3D(irr::scene::ISceneManager* scene, Entity3D* parent, string name = "Renderable", bool uniqueEntity = true)
		: Entity3D(parent, name, uniqueEntity) {
			object = new RenderObject3D(this, scene);
		}

		virtual ~RenderableEntity3D() {
			// Loop through render list and remove pointer to render object
			for (size_t i = 0; i < renderList3D.size(); i++)
				if (object == renderList3D[i])
					renderList3D.erase(i + renderList3D.begin());
			// Delete render object
			delete object;
		}

		RenderObject3D* getRenderObject() {
			return object;
		}
	private:
		RenderObject3D* object;
	};*/
}

#undef DERIVED_CLASS

#endif // GRAPHICAL_RENDERER_H
